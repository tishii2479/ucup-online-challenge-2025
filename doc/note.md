## TODO:
- 入力分布の特定
    - 順位表を使って分布を探る（assert）
- 可視化

- 最後のパケットの到着時刻でスコアが変わる
- timeoutがきつければ追い越すことができる
- 序盤は適当に割り振るで良いなら、後半は最適化できる
    - 種類ごとにおおよそ固定すると良さそう
- ジョブを始めるタイミング
    - 前のジョブが終わったら
    - 新しいパケットが届いたら
- 0-indexed, 1-indexed
- switchを減らすために、同じパケットはなるべく同じコアで処理したい
- コアは一つのノードでしか作業できない
- 基本的にコアの切り替えは少ないほどよい
    - 基本的にはパケットごとに見れば同じコアを使い続けるのが良さそう & そうなりそう
    - 暇な時に割り当てるくらいで良さそう
- ノード8がある & 入力がいつ来るかわからないことを考えると、まとめて最適化するのは筋が悪そう
- コアごとに見れば最も良いものは割と単純に選べそう
    - ノード -> timeoutまでの時間が短い順

## 課題
- いつ読み込むか
    - ペナルティがないなら`c_r`ごとに読み込めば良さそうだが、時間が進むので他のアクションがしづらくなる
    - 操作をしている途中で、読み込みを差し込めるなら都度差し込む
- どのコアを使うか
    - coreごとにイベントを管理すると最適なコアを使えない
    - jobが開始できる時に拾えるパケットを見れば良い
    - 最初だけ面倒かも？
- 少し待った方が良い場合
    - 実際に少し待った場合の評価もする
- 操作の評価
- どうやってバッチにまとめるか
    - 10~20個くらいにまとめれば十分効果がある
- ノード8のコストをどう扱うか
- 実行時間をどう使うか
    - 2sしかない
    - nも5e3くらい
    - 多分大掛かりな最適化はできない

## 解決策
- いくつか工夫すればまとめて焼けそう
- タスクの順序を焼きなます

## タスクの分割
`is_chunked`ではないなら
- idsだけを分ける

`is_chunked`なら
- !is_advanced[i]の個数を比例するように分ける
- !is_advancedが一つもないならis_chunked=false
- idsはis_advancedとの対応に気をつけながら分ける

```
order[core] := [
    Job { job_index, node_index, [(packet_index, path_index)] }
]
job_graph[index]: [dep_jobs]
job_graph[index] {
    同じコアの次のジョブ,
    (packet_index, path_index + 1)を含むジョブ
}
```

- core間のswap, move
- (packet_index, path_index)のjob間の移動, swap
- core内のjobのswap, move

緩和問題を考える
- ノード8がない
- 後から入ってこない

大きな課題
- timeoutをなくす
- 最後をうまくやる
- 稼働していない期間を減らす
    - バッチの分割待ちを減らせれば良い
- ノード8をうまく対処する
- 後から入ってくるものをうまく処理する

- コア間の入れ替わりがないなら、入れ替わりで作業をする必要がない

- stack or queue?
    - priority(idle_task) < priority(core_id) となっているはず
    - stackで良いはず

タスクの作成・優先度
- バッチサイズは一定サイズまで大きい方が良い
- timeoutが間に合う範囲で大きくしている
- たまに他のタスクの開始時刻が遅くなるが、平均で見れば良いはず
- IDEA:
    - packet_typeごとに良いバッチサイズがあるはず
    - バッチサイズが偏らない方が良いはず
        - 32,32,1より22,22,21
    - コアが少ない場合(=1,2)を考えた方が良いかも
    - ギリギリのパケットを捨てた方が良いケースがあるかも

## 課題
- timeoutの最小化
- durationの最小化
    - insertをする悪影響を評価できない
- 貪欲に前から作る悪影響を考慮できていない
    - 後ろのpacketが多くtimeoutするかも
    - 小さいバッチサイズで作成することで、全体が遅れる可能性がある

insert
- タスクの作成も変える必要があるかも: insertする場合には、小さいタスクの方が良い場合がある
    - insertした後で、idle-taskが間に合う必要がある
    - insertして間に合うなら、後でも間に合う？
        - そんなことない
    - あんまり小さいと全体に悪影響が出る
        - min_batch_sizeを導入して、それ未満なら挿入は諦める
- ノード8が判明したことで、挿入できるようになる場合がある
- coreごとに挿入できる`afford`がある
    - `afford_duration := min_time_limit[cur_task] - current_end_time`
    - `next_t + duration <= min_time_limit[new_task]`
    - `duration < afford_duration`になるようにタスクを作成する
    - 多少`cur_task`でtimeoutが出ても、他のコアが引き取ってくれる可能性がある
    - 他のコアの`idle_task`に移すことで、優先的に処理できるかも
- 一般化すると、連鎖的に挿入することになる
    - 基本的に移動が増えると効率が落ちるので、そこまで広い連鎖にはならないはず
- 今はtimeoutしないバッチだけ割り当てている


- lbとubが結構離れている
- ノード8が判明したタイミングで挿入できる可能性が高そう


- なぜ挿入されないのか調べる
- 分割がうまくできない理由を調べる
- 分割を賢くする


## TODO
must
- insertを実装する
- ノード8のinsertを実装する
- 分割するコアの選択基準の改善
    - 中盤まで: 空き時間が少ないコア or idle_task
    - 終盤: 終了が長いコア

want
- 途中までバッチで処理して、間に合わないパケットだけ分割して処理する
- `duration`、`special`の推定を賢くする
    - `works`が溜まってきたら`special_cost_estimate`を再計算する
- タスクの分割方法の改善
    - 現状1/2に分ける
- タスクの作成方法の改善
- taskをマージした方が良い場合は、パケットを追い付かせてマージさせる
    - 全体が遅れるので、少し負の評価をつける
- 最後を局所探索

## IDEA
- 時間が経って、割り込まないといけないタスクができるかも
- 他のコアで同じノードのも消費できるかも
- タスクが長い場合に、少し待ってから分割してから並列処理した方が良い場合があるかも

## LAST
- 一度packetが読まれたら細かく読み込むようにする、終わったら読み込みをやめる
- パラメータのチューニング
    - `max_batch_size`: `n_cores, n, packet_type` ごとに良いバッチサイズがあるはず
- TRACK=false

## others.
- max(score)なので、一つのケースに時間をかけて、他は適当にやる
- 暫定テストケースを探る
