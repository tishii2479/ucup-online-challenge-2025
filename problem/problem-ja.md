# 問題A: HPF マルチコアグラフスケジューリング

種類: インタラクティブ

HPF（High-Performance Forwarding）は、CPUベースのフォワーディングデバイスの中核コンポーネントです。多コアアーキテクチャ（32コア以上）への進化に伴い、スケジューリングアルゴリズムの最適化は高性能なソフトウェアフォワーディングを実現する上で重大なボトルネックとなっています。スケジューリングアルゴリズムを最適化することで、軽量ハードウェア上でもフォワーディング性能を確保しつつコストを削減できます。

この問題では、マルチコアのパケットフォワーディングにおいて、スループットとレイテンシの両方を最適化することを目的としたスケジューリングアルゴリズムを設計してください。HPFのフォワーディング処理は、次の図のような（循環を含む可能性のある）計算グラフとして抽象化できます。

到着したパケットはまず入力ノードに到達し、ノードの系列で処理された後、出力ノードから送出されます。パケットには7種類があり、種類によって通過する経路が異なる可能性があります。計算グラフと計算経路はこの問題を通じて固定です。

各種類のパケットにはレイテンシ制約があります。パケットのレイテンシとは、到着してから送出されるまでの期間です。レイテンシ制約が違反されるたびにスコアが減点されるため、可能であればレイテンシ違反を避けるようにタスク順序をスケジューリングすることが重要です。

HPFの重要な特徴の一つはバッチ処理です。HPFのタスクでは、同一の計算ノード上のパケットのバッチを選択し、スケジューリングアルゴリズムで割り当てられた特定のコア上で計算を実行します。計算時間は計算ノードとバッチサイズに依存します（実際には、ある範囲まではバッチサイズを大きくするほど平均処理効率が向上する傾向があります）。

注意: ノード8は特別なノードです。このノードは最大8つの特殊作業を表します。パケット $i$ がノード8に到達すると、値 $work_i$ が開示されます。$work_i$ の $j$ 番目のビット $work_i[j]$ が1である場合、パケット $i$ に対してノード8上の $j$ 番目の特殊作業を実行する必要があります。ノード8でパケットのバッチを処理するコストには、バッチ内のすべてのパケットに対して必要な特殊作業の合計が追加されます。

HPFシステムのコストモデルは後のセクションで定義します。

もう一つの重要な特徴はマルチコアスケジューリングです。前述の通り、スケジューリングの意思決定は、あるノードでパケットのバッチを選び、そのバッチを特定のコアに割り当ててバッチ処理を行うことです。利用可能なコアは $\text{numcores}$ 個であり、1つのコアは同時に1つのタスクしか処理できません。パケットを別のコアに再割り当てするたびに計算ペナルティが発生します。

本問題の核心は、これらのスケジューリング決定を賢く行い、高いスループットを達成しつつ、レイテンシ制約違反の割合を小さく抑えることです。

この問題はインタラクティブ問題であることに注意してください。解答は標準入力/標準出力ストリームを介してインタラクタと通信します。

---

## インタラクションプロトコル

### 計算グラフ

入力の最初の28行は計算グラフとその対応するコストを説明します。これらの値は全テストケースで固定です。意味は以下の通りです。

- 最初の7行は、各種類のパケットに対する計算経路を示します。各行 $i$ は整数 $l_i$ から始まり、パケット種類 $i$ の計算経路の長さを表します。続く $l_i$ 個の整数は、経路上のノードインデックスを順番に示します。循環によりインデックスが重複することがあります。
- 次の20行では、各行 $i$ が整数 $b_i$ から始まり、ノード $i$ における最大バッチサイズを表します。続く $b_i$ 個の整数 $c_{i,j}$ は、ノード $i$ で $j$ 個のパケットのバッチを処理する計算コストを表します。
- 次の行には8個の整数があり、$i$ 番目の整数 $\mathrm{special\_cost}_i$ はノード8における $i$ 番目の特殊作業の計算コストを表します。

### サブタスク

次の行には3つの整数 $\text{numcores}$, $cswitch$, $cr$ が含まれ、それぞれ使用可能なコア数、パケットを別のコアに再割り当てするコスト、受信試行のコストを表します。

続いて5つのサブタスクがあります。これらは同じパケット種類分布からサンプリングされていますが、スループットが異なります。各サブタスクは独立に解く必要があります。各サブタスクは次のように記述されます。

- サブタスクの最初の行には整数 $n$ が含まれ、このサブタスクのパケット数を表します。整数 $n$ を読み込んだら、さらにデータを受け取るためのインタラクションを開始してください。

あなたは次の4種類のアクションを実行できます。

1. R t: 受信試行
   - 文字 `R` に続けて、呼び出しの開始時刻を示す整数 $t$ を出力します。このアクションは $\text{coreId} = 0$ の追加コア上で実行されます。
   - その後、まず整数 $p$ — 受信したパケット数 — を読み込み、続けて $p$ 行のパケットデータを読み込みます。各行は 4 つの整数 $i, arrive_i, type_i, timeout_i$ を含み、それぞれパケット $i$ のID、到着時刻、種類、タイムアウト閾値を表します。
   - 前回のアクション1の呼び出し以降で、かつ時刻 $t$ 以下に到着したすべてのパケットを受け取ります。受信するパケットは到着時刻順に並んでいます。
   - もし $p = -1$ を読み込んだ場合、これは出力した時刻 $t$ が不正であることを意味します。この場合、直ちにプログラムの実行を停止し、当該テストケースに対して Wrong Answer 判定を受けます。
   - このアクションは時間 $cr$ を要します。アクションの開始時刻は $t$、終了時刻は $t + cr$ です。コア0上で次のアクション1を開始できるのは時刻 $t + cr$ 以降です。

2. E t coreId nodeId s id1 id2 ··· id_s: タスク実行
   - 文字 `E` に続けて、タスクの開始時刻 $t$、タスクを実行するコアのインデックス $\text{coreId}$、計算ノードのインデックス $\text{nodeId}$、バッチ内のパケット数 $s$、そしてバッチ内のパケットID $id_k$（$k = 1..s$）を出力します。
   - 値 $t$ は、$\text{coreId}$ 上の直前アクションの終了時刻以上である必要があります（そのコアで最初のアクションの場合は $0$ より大きい必要があります）。
   - 計算ノード $\text{nodeId}$ は、バッチ内のすべてのパケットの計算経路上に存在しなければなりません。各パケット $id_k$ は、時刻 $t$ にノード $\text{nodeId}$ 上での実行準備ができていなければなりません。
   - もし $\text{nodeId} = 8$ の場合、このアクションはコア $\text{coreId}$ 上で以下の時間を要します:

     $$
     t_a = c_{\text{nodeId},\, s} + \text{numSwitches} \cdot cswitch + \sum_{i=1}^{s} \mathrm{special\_cost}[\,id_i\,]
     $$

     - ここで $\text{numSwitches}$ は、別のコアへ再割り当てされたパケット数です。
     - また、

       $$
       \mathrm{special\_cost}[j] = \sum_{k=1}^{8} work_j[k] \cdot \mathrm{special\_cost}_k
       $$

       は、パケット $j$ のノード8上における特殊作業の総コストです。
   - それ以外のノードの場合、このアクションは以下の時間を要します:

     $$
     t_a = c_{\text{nodeId},\, s} + \text{numSwitches} \cdot cswitch
     $$

   - アクションの開始時刻は $t$、終了時刻は $t + t_a$ です。コア $\text{coreId}$ 上で次のアクション2を開始できるのは時刻 $t + t_a$ 以降です。
   - もし $\text{nodeId}$ がバッチ内のパケット $i$ の計算経路の最後のノードである場合、そのパケット $i$ は時刻 $\text{departure}_i = t + t_a$ に処理完了とみなされます。

3. Q t i: 特殊作業フラグの問い合わせ
   - このアクションは、パケット $i$ がノード8に到達した後にインタラクティブに開示される $work_i$ の値を問い合わせます。
   - このアクションは、ノード8がパケット $i$ の経路上に存在し、時刻 $t$ においてパケット $i$ がノード8の直前ノードでの実行を終えている場合にのみ有効です。
   - このアクションはパケット $i$ に対して最大1回のみ実行できます。
   - アクション後、整数 $work_i$ — パケット $i$ に対応する特殊作業のビットマップ — を読み込みます。もし $work_i = -1$ なら、そのアクションは不正でした。

4. F: サブタスクの終了
   - すべての $n$ 個のパケットの処理が完了した時点で、このアクションを実行する必要があります。
   - すべてのサブタスクが終了するとインタラクションは終了します。解答は実行を停止し、このテストケースに対して Accepted 判定を受けます。その後スコアが計算されます。

---

## 入力制約

- $2 \le n \le 10^4$
- $1 \le m \le 7$
- $1 \le \text{numcores} \le 32$
- $1 \le l_i \le 30$
- $1 \le b_i \le 128$
- $1 \le c_{i,j} \le 10^4$
- $1 \le \mathrm{special\_cost}_i \le 100$
- $1 \le cswitch \le 20$
- $cr = 20$
- $1 \le arrive_i \le 5 \cdot 10^6$
- $1 \le type_i \le 7$
- $1 \le timeout_i \le 10^5$
- $0 \le work_i \le 2^8 - 1$

## 出力制約

- $1 \le t \le 10^7$
- $1 \le \text{coreId} \le \text{numcores}$
- $1 \le \text{nodeId} \le 20$
- $1 \le s \le b_{\text{nodeId}}$
- $1 \le id_i \le n$

各アクションの時刻 $t$ は、直前のアクションの終了時刻以上でなければなりません（もしくは、そのコアでの最初のアクションの場合は $0$ より大きい必要があります）。

---

## スコアリング

HPFの主目的はスループットの最適化ですが、パケットがレイテンシ制約を超えた場合には追加のペナルティが適用されます。したがって、アルゴリズムはこれら2つの指標のバランスを取る必要があります。

サブタスクの設計は、HPFシステムのスループットをどのようにテストするかをモデル化しています。固定のパケット分布に対して、パケットの到着率を徐々に増加させ、システムが過負荷になるまで続けます。

任意の時刻ステップで不正なアクションを行った場合、または出力制約のいずれかに違反した場合、そのテストケースは不正とみなされ、当該テストケースのスコアは 0 点となります。そうでない場合、まずサブタスク別に採点します。$i$ 番目のサブタスクのスコアは次の式で計算されます。

$$
\mathrm{subscore}_i = \max\!\left(0, \left\lfloor \big(\, \mathrm{throughput}_i - 10^4 \cdot \mathrm{timeoutRate}_i \,\big) \cdot 10^2 \right\rfloor \right)
$$

ここで、

$$
\mathrm{throughput}_i = \frac{10^6 \cdot (n - 1)}{\text{numcores} \cdot \big(\max_{1 \le j \le n} \mathrm{departure}_j - \min_{1 \le j \le n} \mathrm{arrive}_j\big)}
$$

- 1秒は $10^6$ 時間単位であり、平均的な1秒あたりの処理パケット数として定義されます。

$$
\mathrm{timeoutRate}_i = \frac{\mathrm{timeoutPkts}_i}{n}
$$

- レイテンシ制約違反の条件は $\;\mathrm{processed}_j - \mathrm{arrive}_j > \mathrm{timeout}_j\;$ です。

テストケースの総合スコアは、そのテストケース内のすべてのサブタスクのスコアの最大値です。

$$
\mathrm{score} = \max_{1 \le i \le 5} \mathrm{subscore}_i
$$

あなたの総合スコアは、すべてのテストケースにわたるスコアの合計です。

---

## 注記

- 予備テストケースは100個あります。提出期間中、予備セットで評価され、各予備テストのスコアがフィードバックされます。
- 10分に1回、コードを提出できます。
- 提出期間終了後の最終評価では200個のテストケースで採点されます。予備テストは最終評価に含まれません。最終結果は1週間後に発表されます。

- processed_j, mが不明瞭
- core_last_tは0でも良いかも